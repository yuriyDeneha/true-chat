/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { HTTP_INTERCEPTORS, HttpHeaders, HttpResponse } from '@angular/common/http';
import { ApplicationRef, Injectable, NgModule } from '@angular/core';
import { BrowserTransferStateModule, TransferState, makeStateKey } from '@angular/platform-browser';
import { of as observableOf } from 'rxjs';
import { tap, take, filter } from 'rxjs/operators';
/**
 * @record
 */
export function TransferHttpResponse() { }
if (false) {
    /** @type {?|undefined} */
    TransferHttpResponse.prototype.body;
    /** @type {?|undefined} */
    TransferHttpResponse.prototype.headers;
    /** @type {?|undefined} */
    TransferHttpResponse.prototype.status;
    /** @type {?|undefined} */
    TransferHttpResponse.prototype.statusText;
    /** @type {?|undefined} */
    TransferHttpResponse.prototype.url;
}
/**
 * @param {?} headers
 * @return {?}
 */
function getHeadersMap(headers) {
    /** @type {?} */
    const headersMap = {};
    for (const key of headers.keys()) {
        headersMap[key] = (/** @type {?} */ (headers.getAll(key)));
    }
    return headersMap;
}
export class TransferHttpCacheInterceptor {
    /**
     * @param {?} appRef
     * @param {?} transferState
     */
    constructor(appRef, transferState) {
        this.transferState = transferState;
        this.isCacheActive = true;
        // Stop using the cache if the application has stabilized, indicating initial rendering is
        // complete.
        appRef.isStable
            .pipe(filter((isStable) => isStable), take(1)).toPromise()
            .then(() => { this.isCacheActive = false; });
    }
    /**
     * @private
     * @param {?} url
     * @return {?}
     */
    invalidateCacheEntry(url) {
        Object.keys(this.transferState['store'])
            .forEach(key => key.includes(url) ? this.transferState.remove(makeStateKey(key)) : null);
    }
    /**
     * @private
     * @param {?} method
     * @param {?} url
     * @param {?} params
     * @return {?}
     */
    makeCacheKey(method, url, params) {
        // make the params encoded same as a url so it's easy to identify
        /** @type {?} */
        const encodedParams = params.keys().sort().map(k => `${k}=${params.get(k)}`).join('&');
        /** @type {?} */
        const key = (method === 'GET' ? 'G.' : 'H.') + url + '?' + encodedParams;
        return makeStateKey(key);
    }
    /**
     * @param {?} req
     * @param {?} next
     * @return {?}
     */
    intercept(req, next) {
        // Stop using the cache if there is a mutating call.
        if (req.method !== 'GET' && req.method !== 'HEAD') {
            this.isCacheActive = false;
            this.invalidateCacheEntry(req.url);
        }
        if (!this.isCacheActive) {
            // Cache is no longer active. Pass the request through.
            return next.handle(req);
        }
        /** @type {?} */
        const storeKey = this.makeCacheKey(req.method, req.url, req.params);
        if (this.transferState.hasKey(storeKey)) {
            // Request found in cache. Respond using it.
            /** @type {?} */
            const response = this.transferState.get(storeKey, (/** @type {?} */ ({})));
            return observableOf(new HttpResponse({
                body: response.body,
                headers: new HttpHeaders(response.headers),
                status: response.status,
                statusText: response.statusText,
                url: response.url,
            }));
        }
        else {
            // Request not found in cache. Make the request and cache it.
            /** @type {?} */
            const httpEvent = next.handle(req);
            return httpEvent
                .pipe(tap((event) => {
                if (event instanceof HttpResponse) {
                    this.transferState.set(storeKey, {
                        body: event.body,
                        headers: getHeadersMap(event.headers),
                        status: event.status,
                        statusText: event.statusText,
                        url: (/** @type {?} */ (event.url)),
                    });
                }
            }));
        }
    }
}
TransferHttpCacheInterceptor.decorators = [
    { type: Injectable }
];
/** @nocollapse */
TransferHttpCacheInterceptor.ctorParameters = () => [
    { type: ApplicationRef },
    { type: TransferState }
];
if (false) {
    /**
     * @type {?}
     * @private
     */
    TransferHttpCacheInterceptor.prototype.isCacheActive;
    /**
     * @type {?}
     * @private
     */
    TransferHttpCacheInterceptor.prototype.transferState;
}
/**
 * An NgModule used in conjunction with `ServerTransferHttpCacheModule` to transfer cached HTTP
 * calls from the server to the client application.
 */
export class TransferHttpCacheModule {
}
TransferHttpCacheModule.decorators = [
    { type: NgModule, args: [{
                imports: [BrowserTransferStateModule],
                providers: [
                    TransferHttpCacheInterceptor,
                    { provide: HTTP_INTERCEPTORS, useExisting: TransferHttpCacheInterceptor, multi: true },
                ],
            },] }
];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJhbnNmZXJfaHR0cC5qcyIsInNvdXJjZVJvb3QiOiIuLi8uLi8iLCJzb3VyY2VzIjpbIm1vZHVsZXMvY29tbW9uL3NyYy90cmFuc2Zlcl9odHRwLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBT0EsT0FBTyxFQUNMLGlCQUFpQixFQUdqQixXQUFXLEVBR1gsWUFBWSxFQUViLE1BQU0sc0JBQXNCLENBQUM7QUFDOUIsT0FBTyxFQUFDLGNBQWMsRUFBRSxVQUFVLEVBQUUsUUFBUSxFQUFDLE1BQU0sZUFBZSxDQUFDO0FBQ25FLE9BQU8sRUFDTCwwQkFBMEIsRUFDMUIsYUFBYSxFQUNiLFlBQVksRUFFYixNQUFNLDJCQUEyQixDQUFDO0FBQ25DLE9BQU8sRUFBYSxFQUFFLElBQUksWUFBWSxFQUFDLE1BQU0sTUFBTSxDQUFDO0FBQ3BELE9BQU8sRUFBQyxHQUFHLEVBQUUsSUFBSSxFQUFFLE1BQU0sRUFBQyxNQUFNLGdCQUFnQixDQUFDOzs7O0FBRWpELDBDQU1DOzs7SUFMQyxvQ0FBa0I7O0lBQ2xCLHVDQUFrQzs7SUFDbEMsc0NBQWdCOztJQUNoQiwwQ0FBb0I7O0lBQ3BCLG1DQUFhOzs7Ozs7QUFHZixTQUFTLGFBQWEsQ0FBQyxPQUFvQjs7VUFDbkMsVUFBVSxHQUErQixFQUFFO0lBQ2pELEtBQUssTUFBTSxHQUFHLElBQUksT0FBTyxDQUFDLElBQUksRUFBRSxFQUFFO1FBQ2hDLFVBQVUsQ0FBQyxHQUFHLENBQUMsR0FBRyxtQkFBQSxPQUFPLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxFQUFDLENBQUM7S0FDeEM7SUFDRCxPQUFPLFVBQVUsQ0FBQztBQUNwQixDQUFDO0FBR0QsTUFBTSxPQUFPLDRCQUE0Qjs7Ozs7SUFnQnZDLFlBQVksTUFBc0IsRUFBVSxhQUE0QjtRQUE1QixrQkFBYSxHQUFiLGFBQWEsQ0FBZTtRQWRoRSxrQkFBYSxHQUFHLElBQUksQ0FBQztRQWUzQiwwRkFBMEY7UUFDMUYsWUFBWTtRQUNaLE1BQU0sQ0FB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QUMsYUFBYSxDQUFDLEdBQUcsQ0FBQyxRQUFRLEVBQUU7d0JBQy9CLElBQUksRUFBRSxLQUFLLENBQUMsSUFBSTt3QkFDaEIsT0FBTyxFQUFFLGFBQWEsQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDO3dCQUNyQyxNQUFNLEVBQUUsS0FBSyxDQUFDLE1BQU07d0JBQ3BCLFVBQVUsRUFBRSxLQUFLLENBQUMsVUFBVTt3QkFDNUIsR0FBRyxFQUFFLG1CQUFBLEtBQUssQ0FBQyxHQUFHLEVBQUM7cUJBQ2hCLENBQUMsQ0FBQztpQkFDSjtZQUNILENBQUMsQ0FBQyxDQUNILENBQUM7U0FDTDtJQUNILENBQUM7OztZQXRFRixVQUFVOzs7O1lBMUJILGNBQWM7WUFHcEIsYUFBYTs7Ozs7OztJQTBCYixxREFBNkI7Ozs7O0lBY08scURBQW9DOzs7Ozs7QUFtRTFFLE1BQU0sT0FBTyx1QkFBdUI7OztZQVBuQyxRQUFRLFNBQUM7Z0JBQ1IsT0FBTyxFQUFFLENBQUMsMEJBQTBCLENBQUM7Z0JBQ3JDLFNBQVMsRUFBRTtvQkFDVCw0QkFBNEI7b0JBQzVCLEVBQUMsT0FBTyxFQUFFLGlCQUFpQixFQUFFLFdBQVcsRUFBRSw0QkFBNEIsRUFBRSxLQUFLLEVBQUUsSUFBSSxFQUFDO2lCQUNyRjthQUNGIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5pbXBvcnQge1xuICBIVFRQX0lOVEVSQ0VQVE9SUyxcbiAgSHR0cEV2ZW50LFxuICBIdHRwSGFuZGxlcixcbiAgSHR0cEhlYWRlcnMsXG4gIEh0dHBJbnRlcmNlcHRvcixcbiAgSHR0cFJlcXVlc3QsXG4gIEh0dHBSZXNwb25zZSxcbiAgSHR0cFBhcmFtc1xufSBmcm9tICdAYW5ndWxhci9jb21tb24vaHR0cCc7XG5pbXBvcnQge0FwcGxpY2F0aW9uUmVmLCBJbmplY3RhYmxlLCBOZ01vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge1xuICBCcm93c2VyVHJhbnNmZXJTdGF0ZU1vZHVsZSxcbiAgVHJhbnNmZXJTdGF0ZSxcbiAgbWFrZVN0YXRlS2V5LFxuICBTdGF0ZUtleVxufSBmcm9tICdAYW5ndWxhci9wbGF0Zm9ybS1icm93c2VyJztcbmltcG9ydCB7T2JzZXJ2YWJsZSwgb2YgYXMgb2JzZXJ2YWJsZU9mfSBmcm9tICdyeGpzJztcbmltcG9ydCB7dGFwLCB0YWtlLCBmaWx0ZXJ9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcblxuZXhwb3J0IGludGVyZmFjZSBUcmFuc2Zlckh0dHBSZXNwb25zZSB7XG4gIGJvZHk/OiBhbnkgfCBudWxsO1xuICBoZWFkZXJzPzoge1trOiBzdHJpbmddOiBzdHJpbmdbXX07XG4gIHN0YXR1cz86IG51bWJlcjtcbiAgc3RhdHVzVGV4dD86IHN0cmluZztcbiAgdXJsPzogc3RyaW5nO1xufVxuXG5mdW5jdGlvbiBnZXRIZWFkZXJzTWFwKGhlYWRlcnM6IEh0dHBIZWFkZXJzKSB7XG4gIGNvbnN0IGhlYWRlcnNNYXA6IHtbbmFtZTogc3RyaW5nXTogc3RyaW5nW119ID0ge307XG4gIGZvciAoY29uc3Qga2V5IG9mIGhlYWRlcnMua2V5cygpKSB7XG4gICAgaGVhZGVyc01hcFtrZXldID0gaGVhZGVycy5nZXRBbGwoa2V5KSE7XG4gIH1cbiAgcmV0dXJuIGhlYWRlcnNNYXA7XG59XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBUcmFuc2Zlckh0dHBDYWNoZUludGVyY2VwdG9yIGltcGxlbWVudHMgSHR0cEludGVyY2VwdG9yIHtcblxuICBwcml2YXRlIGlzQ2FjaGVBY3RpdmUgPSB0cnVlO1xuXG4gIHByaXZhdGUgaW52YWxpZGF0ZUNhY2hlRW50cnkodXJsOiBzdHJpbmcpIHtcbiAgICBPYmplY3Qua2V5cyh0aGlzLnRyYW5zZmVyU3RhdGVbJ3N0b3JlJ10pXG4gICAgICAuZm9yRWFjaChrZXkgPT4ga2V5LmluY2x1ZGVzKHVybCkgPyB0aGlzLnRyYW5zZmVyU3RhdGUucmVtb3ZlKG1ha2VTdGF0ZUtleShrZXkpKSA6IG51bGwpO1xuICB9XG5cbiAgcHJpdmF0ZSBtYWtlQ2FjaGVLZXkobWV0aG9kOiBzdHJpbmcsIHVybDogc3RyaW5nLCBwYXJhbXM6IEh0dHBQYXJhbXMpOiBTdGF0ZUtleTxzdHJpbmc+IHtcbiAgICAvLyBtYWtlIHRoZSBwYXJhbXMgZW5jb2RlZCBzYW1lIGFzIGEgdXJsIHNvIGl0J3MgZWFzeSB0byBpZGVudGlmeVxuICAgIGNvbnN0IGVuY29kZWRQYXJhbXMgPSBwYXJhbXMua2V5cygpLnNvcnQoKS5tYXAoayA9PiBgJHtrfT0ke3BhcmFtcy5nZXQoayl9YCkuam9pbignJicpO1xuICAgIGNvbnN0IGtleSA9IChtZXRob2QgPT09ICdHRVQnID8gJ0cuJyA6ICdILicpICsgdXJsICsgJz8nICsgZW5jb2RlZFBhcmFtcztcbiAgICByZXR1cm4gbWFrZVN0YXRlS2V5PFRyYW5zZmVySHR0cFJlc3BvbnNlPihrZXkpO1xuICB9XG5cbiAgY29uc3RydWN0b3IoYXBwUmVmOiBBcHBsaWNhdGlvblJlZiwgcHJpdmF0ZSB0cmFuc2ZlclN0YXRlOiBUcmFuc2ZlclN0YXRlKSB7XG4gICAgLy8gU3RvcCB1c2luZyB0aGUgY2FjaGUgaWYgdGhlIGFwcGxpY2F0aW9uIGhhcyBzdGFiaWxpemVkLCBpbmRpY2F0aW5nIGluaXRpYWwgcmVuZGVyaW5nIGlzXG4gICAgLy8gY29tcGxldGUuXG4gICAgYXBwUmVmLmlzU3RhYmxlXG4gICAgICAucGlwZShcbiAgICAgICAgZmlsdGVyKChpc1N0YWJsZTogYm9vbGVhbikgPT4gaXNTdGFibGUpLFxuICAgICAgICB0YWtlKDEpXG4gICAgICApLnRvUHJvbWlzZSgpXG4gICAgICAudGhlbigoKSA9PiB7IHRoaXMuaXNDYWNoZUFjdGl2ZSA9IGZhbHNlOyB9KTtcbiAgfVxuXG4gIGludGVyY2VwdChyZXE6IEh0dHBSZXF1ZXN0PGFueT4sIG5leHQ6IEh0dHBIYW5kbGVyKTogT2JzZXJ2YWJsZTxIdHRwRXZlbnQ8YW55Pj4ge1xuICAgIC8vIFN0b3AgdXNpbmcgdGhlIGNhY2hlIGlmIHRoZXJlIGlzIGEgbXV0YXRpbmcgY2FsbC5cbiAgICBpZiAocmVxLm1ldGhvZCAhPT0gJ0dFVCcgJiYgcmVxLm1ldGhvZCAhPT0gJ0hFQUQnKSB7XG4gICAgICB0aGlzLmlzQ2FjaGVBY3RpdmUgPSBmYWxzZTtcbiAgICAgIHRoaXMuaW52YWxpZGF0ZUNhY2hlRW50cnkocmVxLnVybCk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmlzQ2FjaGVBY3RpdmUpIHtcbiAgICAgIC8vIENhY2hlIGlzIG5vIGxvbmdlciBhY3RpdmUuIFBhc3MgdGhlIHJlcXVlc3QgdGhyb3VnaC5cbiAgICAgIHJldHVybiBuZXh0LmhhbmRsZShyZXEpO1xuICAgIH1cblxuICAgIGNvbnN0IHN0b3JlS2V5ID0gdGhpcy5tYWtlQ2FjaGVLZXkocmVxLm1ldGhvZCwgcmVxLnVybCwgcmVxLnBhcmFtcyk7XG5cbiAgICBpZiAodGhpcy50cmFuc2ZlclN0YXRlLmhhc0tleShzdG9yZUtleSkpIHtcbiAgICAgIC8vIFJlcXVlc3QgZm91bmQgaW4gY2FjaGUuIFJlc3BvbmQgdXNpbmcgaXQuXG4gICAgICBjb25zdCByZXNwb25zZSA9IHRoaXMudHJhbnNmZXJTdGF0ZS5nZXQoc3RvcmVLZXksIHt9IGFzIFRyYW5zZmVySHR0cFJlc3BvbnNlKTtcbiAgICAgIHJldHVybiBvYnNlcnZhYmxlT2YobmV3IEh0dHBSZXNwb25zZTxhbnk+KHtcbiAgICAgICAgYm9keTogcmVzcG9uc2UuYm9keSxcbiAgICAgICAgaGVhZGVyczogbmV3IEh0dHBIZWFkZXJzKHJlc3BvbnNlLmhlYWRlcnMpLFxuICAgICAgICBzdGF0dXM6IHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgc3RhdHVzVGV4dDogcmVzcG9uc2Uuc3RhdHVzVGV4dCxcbiAgICAgICAgdXJsOiByZXNwb25zZS51cmwsXG4gICAgICB9KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJlcXVlc3Qgbm90IGZvdW5kIGluIGNhY2hlLiBNYWtlIHRoZSByZXF1ZXN0IGFuZCBjYWNoZSBpdC5cbiAgICAgIGNvbnN0IGh0dHBFdmVudCA9IG5leHQuaGFuZGxlKHJlcSk7XG4gICAgICByZXR1cm4gaHR0cEV2ZW50XG4gICAgICAgIC5waXBlKFxuICAgICAgICAgIHRhcCgoZXZlbnQ6IEh0dHBFdmVudDxhbnk+KSA9PiB7XG4gICAgICAgICAgICBpZiAoZXZlbnQgaW5zdGFuY2VvZiBIdHRwUmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgdGhpcy50cmFuc2ZlclN0YXRlLnNldChzdG9yZUtleSwge1xuICAgICAgICAgICAgICAgIGJvZHk6IGV2ZW50LmJvZHksXG4gICAgICAgICAgICAgICAgaGVhZGVyczogZ2V0SGVhZGVyc01hcChldmVudC5oZWFkZXJzKSxcbiAgICAgICAgICAgICAgICBzdGF0dXM6IGV2ZW50LnN0YXR1cyxcbiAgICAgICAgICAgICAgICBzdGF0dXNUZXh0OiBldmVudC5zdGF0dXNUZXh0LFxuICAgICAgICAgICAgICAgIHVybDogZXZlbnQudXJsISxcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBBbiBOZ01vZHVsZSB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggYFNlcnZlclRyYW5zZmVySHR0cENhY2hlTW9kdWxlYCB0byB0cmFuc2ZlciBjYWNoZWQgSFRUUFxuICogY2FsbHMgZnJvbSB0aGUgc2VydmVyIHRvIHRoZSBjbGllbnQgYXBwbGljYXRpb24uXG4gKi9cbkBOZ01vZHVsZSh7XG4gIGltcG9ydHM6IFtCcm93c2VyVHJhbnNmZXJTdGF0ZU1vZHVsZV0sXG4gIHByb3ZpZGVyczogW1xuICAgIFRyYW5zZmVySHR0cENhY2hlSW50ZXJjZXB0b3IsXG4gICAge3Byb3ZpZGU6IEhUVFBfSU5URVJDRVBUT1JTLCB1c2VFeGlzdGluZzogVHJhbnNmZXJIdHRwQ2FjaGVJbnRlcmNlcHRvciwgbXVsdGk6IHRydWV9LFxuICBdLFxufSlcbmV4cG9ydCBjbGFzcyBUcmFuc2Zlckh0dHBDYWNoZU1vZHVsZSB7fVxuIl19